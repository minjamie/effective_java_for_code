## item29. 이왕이면 제네릭 타입으로 만들라
JDK가 제공하는 제네릭 타입과 메서드를 사용하는 일은 일반적으로 쉬운 편이지만, 제네릭 타입을 새로 만드는 일은 조금 더 어렵다.  
배워두면 값어치가 충분하기때문에 살펴보자!  

### Object 기반 스택 예제코드 - 제네릭이 절실한 강력 후보
스택에서 꺼낸 객체를 클라이언트가 형변환해야하는데 런타임 오류가 날 위험이 있으므로 클래스를 제네릭으로 바꾸도록한다.  

### 제네릭 스택으로 가는 첫단계 - 컴파일이 되지 않는다.
일반클래스를 제네릭 클래스로 만드는 첫단걔는 클래스 선언에 타입 매개변수를 추가하는 일  
타입이름으로는 보통 E를 사용한다.  
(예제코드 Stack2)  

### E와 같은 실체화 불가타입으로는 배열을 만들 수 없다.  
-> 두가지 해결책  
1. 제네릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법 (Stack3예제코드)  
: Object 배열을 생성한 다음 제네릭 배열로 형변환  
-> 일반적으로 타입안전하지 않지만 컴파일러는 오류대신 경고를 내보냄  
컴파일러는 이 프로그램이 타입 안전한지 증명할 방법이 없기때문에 직접 타입 안전성을 해치지 않음을 확인해야한다.   
-> 비검사 형변환이 안전함을 증명했다면 범위를 최소로 좁혀 @SuppressWarnings 애너테이션으로 해당 경고를 숨기도록 한다.  
2. elements 필드의 타입을 E[]에서 Object[]로 바꾸는것 (Stack4예제코드)  
-> E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없다.  
따라서 직접 증명하고 경고를 숨기도록한다.  

#### 두 해결책 비교
- 첫번째 방법이 가독성이 더 좋음(배열타입을 E[]로 선언하여 오직 E타입 인스턴스만 받은을 확실히 어필/코드짧음)  
- 제네릭클래스라면 배열을 코드이곳저곳에서 자주사용할것인데 첫번째에서는 배열생성시 단 한번만 형변환을 해주면된다.  
두번째방식은 배열에서 원소를 읽을때마다 형변환을 해줘야한다.  
-> 현업에서는 첫번째가 더 선호됨  
- 하지만, E가 Object 가 아닌이상 배열의 런타임 타입이 컴파일타임 타입과 다르기때문에 힙 오염(heap pollution)을 일으키니 주의  

### 대다수 제네릭타입은 타입매개변수에 아무런 제약을 두지않는다.
- 단, 기본타입은 사용할 수 없다. -> 자바 제네릭타입시스템의 근본적인문제(박싱된 기본타입을 사용해 우회)  
- 타입매개변수에 제약을 두는 제네릭타입도 있는데 java.util.concurrent.DelayQueue 가 그 예  

#### java.util.concurrent.DelayQueue
`E extends Delayed`  
- java.util.concurrent.Delayed 의 하위 타입만 받는다는 뜻이다.  
- DelayQueue 의 원소에서 형변환 없이 곧바로 Delayed 클래스의 메서드를 호출할 수 있다.  
- 이러한 타입 매개변수 E를 한정적 타입 매개변수(bounded type parameter)라 한다.  
- 추가로, 모든 타입은 자기 자신의 하위 타입이므로 `DelayQueue<Delayed>`로도 사용할 수 있다.  

### 핵심정리
- 클라이언트에서 직접 형변환해야하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하므로  
새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록하라.  
(그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다.)  
- 기존 타입 중 제네릭이었어야 하는게 있다면 제네릭 타입으로 변경하자.  
-> 기존 클라이언트에는 아무 영향을 주지않으면서 새로운 사용자를 훨씬 편하게 해주는 길이다.  