## item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

좋은 API 문서란 '어떻게'가 아닌 '무엇을' 하는지를 설명해야 한다는 격언이 있지만  
그와 대치되게 상속은 캡슐화를 해치기때문에 클래스를 안전하게 상속할 수 있도록 내부구현방식을 설명해야만한다.  

### 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 (자기 사용) 문서로 남겨야 한다.
클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수 있다.  
이때 호출한 메서드가 재정의 가능한 메서드라면, 이 사실을 메서드의 API 설명에 명시해야 한다.  
명시할때에는 어떤순서로 호출하고, 각각 호출 결과가 이어지는 처리에 어떤 영향을 주는지 등 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.

이를 도와주는 용도로 `@implSpec`를 이용하면  
javadoc이 내부 동작 방식을 설명하는 "Implementation Requirements"절을 생성해준다.


### 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook 을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
효율적인 하위 클래스를 큰 어려움 없이 만들려면 내부 매커니즘을 문서로 남기는것뿐만 아니라  
클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.  

ex) AbstractList - removeRange 메서드  
removeRange 메서드를 제공한 이유는 단지 하위 클래스의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서이다.  

### 상속용 클래스를 설계할 때 어떤 메서드를 protected 로 노출해야 할지는 어떻게 결정할까?  
심사숙고해서 잘 예측해보고, 실제 하위 클래스를 만들어 테스트해보는 것이 최선이다.  
다만, protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적은 게 좋으며,  
너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.  

### 상속용 클래스를 설계하면서 한 결정들이 클래스의 성능과 기능에 족쇄가 될 수 있음을 인식해서 반드시 배포 전에 하위 클래스를 만들어 검증하자.  
상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.  
(책에서는 검증에 하위클래스 3개정도가 적당하고 이중 하나 이상은 제 3자가 작성해봐야한다고 함)  
하위 클래스를 만들어 검증을 하면, 꼭 필요한 protected 멤버를 놓쳤을때 검증 도중에 빈자리가 확연히 드러날 것이다.  
검증하며 사용되지 않는 protected 멤버가 있다면 그 멤버는 private 이어야 할 가능성이 크다.


### 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
이 규칙을 어기면 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로  
하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.  
이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않는다.  

ex) Super.java, Sub.java  

하위 클래스의 생성자보다 상위 클래스의 생성자가 먼저 호출되는데,  
상위 클래스의 생성자에서 하위 클래스의 재정의된 메서드를 호출하여 Date 값이 초기화되기 전에 접근하기 때문에 null 값이 출력된다.  
만약 `println`이 아니었다면, `NullpointerException`을 반환했을 것이다.  

이와 같은 현상은 `Cloneable`과 `Serializeable` 인터페이스의 `clone` 메서드와 `readObject` 메서드에서도 나타나는데,  
두 메서드가 새로운 객체를 생성하는 효과(생성자와 비슷)를 가지기 때문이다.  
따라서 `clone`과 `readObject` 모두 직간접적으로 재정의가능 메서드를 호출해서는 안된다.


### 상속용으로 설계하지 않은 클래스는 상속을 금지한다.
상속용으로 설계되지 않은 클래스는 클래스에 변화가 생길 때마다 하위 클래스에 오작동을 일으킬 수 있다.  
따라서 상속용으로 설계되지 않았다면 상속을 금지해야 한다.  

#### 상속을 금지하는 방법
1. 클래스를 final 로 선언한다.
2. 모든 생성자를 private 나 default 로 선언하고 public 정적 팩터리를 만든다.

#### 하지만 꼭 상속을 허용해야 한다면,  
1. 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게한다.  
재정의가능메서드대신 도우미메서드를 이용하도록 함 - 본문 코드를 private 메서드(도우미메서드)로 옮기고, 이 도우미 메서드를 호출  
ex) Helper.java
2. 해당 사실을 문서로 남긴다.  

이렇게 한다면 상속해도 그리 위험하지 않은 클래스를 만들 수 있다.  


### 핵심정리
- 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는한 반드시 지켜야한다.  
  그렇지 않으면 그 내부 구현방식을 믿고 활용하던 하위클래스를 오동작하게 만들 수 있다.  
- 클래스를 확장해야할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.  